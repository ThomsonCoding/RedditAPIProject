const resultsSection = document.querySelector('.search__results__list');
const chartBox = document.querySelector('.chart__box');

//Both of these hold the data for the original search. Which allow the user to go back to the original state after manipulating the data with the search functions. 
let originalSearch;
let previousData;
let previousDate; 
let previousScore;
let resultsChart;

const generateUi = (data) => {
    originalSearch = data;
    //Using the removingOldData function to get rid of the previous graph and comments. Then generating a base one for new info to be fed to. 
    removingOldData(resultsSection);
    removingOldData(chartBox);
    generateNewGraph();

    const redditResults = data.data;
    let scores = [];
    let date = [];

    // For each returned result, this generates a table displaying the username, content and time/date.
    redditResults.forEach((dataSet, i)=> {
        const list = document.createElement('li');
        resultsSection.appendChild(list);

        const author = document.createElement('h3');
        author.textContent = dataSet.author;

        const content = document.createElement('p');
        content.textContent = dataSet.body;

        const contentScore = document.createElement('p');
        contentScore.textContent = dataSet.score;
        scores.push(dataSet.score);

        const timeStamp = document.createElement('h6');
        var Epoch = new Date(dataSet.created_utc *1000 + (86400000 * i)).toDateString();
        timeStamp.textContent = Epoch;
        date.push(Epoch);

        [author, content, timeStamp, contentScore].forEach(el => list.appendChild(el));
    });

    previousDate = date;
    previousScore = scores;
    generateGraph(originalSearch, resultsChart, date, scores);
}

//Used to remove the previous search data. 
const removingOldData = (parent) => {
    while (parent.firstChild) {
        parent.firstChild.remove();
    }  
}

const findDataSet = (originalSearch, index) => {
    return originalSearch.data[index].author;
}

const findDataText = (originalSearch, index) => {
    const seeMore = document.createElement('a');
    seeMore.textContent = "See more";
    // seeMore.href = `https://www.reddit.com/${originalSearch.data[index].permalink}`;
    return originalSearch.data[index].body.slice(0, 20) + "..." + seeMore;
}


// Using Chart.js to generate the graph, it feeds the latest data/scores. Then adds the data to new Canvas which was generated by the generateNewGraph function. 
const generateGraph = (SearchData, resultsChart, date, scores) => {

    previousData = SearchData;

    const labels = date;
    const testData = {
        labels: labels,
        datasets: [{
        label: 'Comment scores',
        backgroundColor: 'rgb(255, 255, 132)',
        borderColor: 'rgb(45, 107, 169)',
        data: scores, 
        }]
    };
    
    const config = {
        type: 'line',
        data: testData,
        options: {
            plugins: {
                tooltip: {
                    callbacks: {
                        beforeTitle: function(context) {
                            return findDataSet(SearchData,  context[0].dataIndex);
                        },
                        title: function(context) {
                            return context[0].label;
                        },
                        afterTitle: function(context) {
                            return `Score: ${context[0].formattedValue}`
                        },
                        body: function(context) {
                            return `Score: ${context[0].formattedValue}`
                        },
                        afterBody: function(context) {
                            return findDataText(SearchData,  context[0].dataIndex);
                        },
                        label: function(context) {
                            return;
                        }              
                    },
                    titleFontSize: 16,
                    bodyFontSize: 14,
                    displayColors: false
                }
            }
        }
    };

    const myChart = 
    new Chart( resultsChart,
        config
    );

    searchFunction(SearchData, date, scores); 
    console.log(SearchData, resultsChart, date, scores);
}

// This generates and provides the funtionality for the search function (Which is used when searching different dates within the graph).
const searchFunction = (SearchData, date, scores) => {
    //Gets the lowest and highest score in the data to provide a range for the users to seach between. 
    let min = Math.min(...scores);
    let max = Math.max(...scores);

    //Data Search Function section.
    const searchSections = document.createElement('section');
    searchSections.classList.add('search__sections');
    
    // This generates the radio section for organising by dates or score.
    const radioSection = document.createElement('form');
    radioSection.classList.add('radio__section');
    searchSections.appendChild(radioSection);

    //This generates the radio date button.
    const dateRadioLabel = document.createElement('label');
    dateRadioLabel.innerText = "Date";
    dateRadioLabel.for = "dateRadio";

    const dateRadio = document.createElement('input');
    dateRadio.type = "radio"
    dateRadio.value = "dateRadio";
    dateRadio.name = "search_type";

    //This generates the radio score button.
    const scoreRadioLabel = document.createElement('label');
    scoreRadioLabel.innerText = "Score";
    scoreRadioLabel.for = "scoreRadio";
    

    const scoreRadio = document.createElement('input');
    scoreRadio.type = "radio"
    scoreRadio.value = "scoreRadio";
    scoreRadio.name = "search_type";

    [dateRadioLabel, dateRadio,  scoreRadioLabel, scoreRadio ].forEach(el => radioSection.appendChild(el));

    const radioSubmit = document.createElement('button');
    radioSubmit.innerText = "Sort by: (Date/Score)"
    radioSubmit.classList.add('graph__button');
    radioSubmit.addEventListener("click", () => {
        radioFunctionality(SearchData, date, scores);
    });

    //This generates the search functionality for the score. 
    const scoreSliderSection = document.createElement('section');
    scoreSliderSection.classList.add('score__slider__section');
    searchSections.appendChild(scoreSliderSection);

    //Generates the score From slider and its properties. 
    const scoreFromLabel = document.createElement('p');
    scoreFromLabel.innerText = `Score From: ${min}`;

    const scoreFromSlider = document.createElement('input');
    scoreFromSlider.type = "range";
    scoreFromSlider.min = (min - 1);
    scoreFromSlider.max = (max + 1);
    scoreFromSlider.value = (min - 1);

    const scoreFromOutput = document.createElement('output');

    scoreFromSlider.oninput = () => {
        scoreFromLabel.innerText = `Score From: ${scoreFromSlider.value}`;
    }

    //Generates the score To slider and its properties. 
    const scoreToLabel = document.createElement('p');
    scoreToLabel.innerText = `Score To: ${max}`;

    const scoreToSlider = document.createElement('input');
    scoreToSlider.type = "range";
    scoreToSlider.min = (min - 1);
    scoreToSlider.max = (max + 1);
    scoreToSlider.step = 1;
    scoreToSlider.value = (max + 1);

    const scoreToOutput = document.createElement('output');

    scoreToSlider.oninput = () => {
        scoreToLabel.innerText = `Score To: ${scoreToSlider.value}`;
    }

    // This generates the search functionality for the dates From and dates To.
    const dateDropdownSection = document.createElement('section');
    dateDropdownSection.classList.add('date__dropdown__section');
    searchSections.appendChild(dateDropdownSection)

    const dateFromLabel = document.createElement('p');
    dateFromLabel.innerText = 'Date From:'

    const dateFromSlider = document.createElement('select');

    date.forEach(day => {
        const dateOption = document.createElement('option');
        dateOption.innerText = day;
        dateFromSlider.append(dateOption);
    })

    const dateToLabel = document.createElement('p');
    dateToLabel.innerText = 'Date To:'

    const dateToSlider = document.createElement('select');

    date.forEach(day => {
        const dateOption = document.createElement('option');
        dateOption.innerText = day;
        dateToSlider.append(dateOption);
    })

    const graphButtonSection = document.createElement('section');
    graphButtonSection.classList.add('graph_button_section');

    //Creates the score filter button.
    const scoreSearchButton = document.createElement('button');
    scoreSearchButton.classList.add('graph__button');
    scoreSearchButton.innerText = "Search Score";
    scoreSearchButton.addEventListener("click", () => {
        scoresFilter(date, scores, scoreFromSlider.value, scoreToSlider.value);
    });


    //Creates the search button and it's functionality. 
    const dateSearchButton = document.createElement('button');
    dateSearchButton.classList.add('graph__button')
    dateSearchButton.innerText = "Search Dates"
    dateSearchButton.addEventListener("click", () => { 
        const dateFromKey = getKeyByValue(date, dateFromSlider.value);  
        const dateToKey = getKeyByValue(date, dateToSlider.value);      

        if (Number(dateFromKey) >= Number(dateToKey)) {
            alert('"Date From..." should be earlier than "Date To..."');
        } else {   
            const filteredDate = date.slice(dateFromKey, dateToKey);
            const filteredScores = scores.slice(dateFromKey, dateToKey);     
            const filteredOriginalSearch = previousData.data.slice(dateFromKey, dateToKey);
            removingOldData(chartBox);
            generateNewGraph();

        console.log({data: filteredOriginalSearch}, resultsChart, filteredDate, filteredScores);
        generateGraph({data: filteredOriginalSearch}, resultsChart, filteredDate, filteredScores);
        }


    });

    //Creates the reset button and it's functionality. 
    const resetSearchButton = document.createElement('button');
    resetSearchButton.classList.add('graph__button')    
    resetSearchButton.innerText = "Reset Graph"
    resetSearchButton.addEventListener("click", () => {

        removingOldData(chartBox);
        generateNewGraph();

        generateGraph(originalSearch, resultsChart, previousDate, previousScore);
    });


    //This appends all the score search features that are found within the score__slider__section.
    [scoreFromLabel, scoreFromSlider, scoreFromOutput, scoreToLabel, scoreToSlider, scoreToOutput].forEach(el => scoreSliderSection.appendChild(el));
    //This appends the date drop downs, that are found within the date_dropdown_section.
    [dateFromLabel, dateFromSlider, dateToLabel, dateToSlider].forEach(el => dateDropdownSection.appendChild(el));
    //This attatches all the buttons required for manipulating the graph. (Search Score, Search Dates and Reset Graph)
    [radioSubmit, scoreSearchButton, dateSearchButton, resetSearchButton].forEach(el =>  graphButtonSection.appendChild(el));   
    //Attatches the graph_button_section to the chart__box (Which holds the search features and buttons)
    [searchSections, graphButtonSection].forEach(el => chartBox.appendChild(el));
    
}


// This gets the key of the selected element. Which is used to help slice the dates and score to update the graph.
function getKeyByValue(object, value) {
    return Object.keys(object).find(key => object[key] === value);
}

const scoresFilter = (date, scores, scoreFromSlider, scoreToSlider) => {

    if (Number(scoreFromSlider) > Number(scoreToSlider)) {
        alert('Error');
        return;
    }

    //resultsChart Add this as the first variable.
    let lowestScore = scoreFromSlider;
    let highestScore = scoreToSlider;
    let countChecker = [];
    let filteredScoreList = [];
    let filteredDateList = [];
    let filteredOriginalSearch = [];

    scores.forEach((score, i) => {
        if(score > lowestScore && score < highestScore) {
            countChecker.push(i);
            filteredScoreList.push(score);
            filteredDateList.push(date[i]);
            filteredOriginalSearch.push(originalSearch.data[i]);
        }

        removingOldData(chartBox);
        generateNewGraph();
        generateGraph({data: filteredOriginalSearch}, resultsChart, filteredDateList, filteredScoreList);   
    })
};

const radioFunctionality = (SearchData, date, scores) => {

    let sortedContent = [];
    let sortedScore = [];
    let sortedDate = [];
    let sortedData = [];

    let checkedBox = document.querySelector('input[name="search_type"]:checked').value;
    if (checkedBox === "dateRadio") {
        scores.forEach((score, i) => { sortedContent.push([score, date[i], SearchData.data[i]]) } );
        sortedContent.sort(function(a,b) {
            return new Date(a[1]) - new Date(b[1]);
        });

        sortedContent.forEach(scoreAndDate => {
            sortedScore.push(scoreAndDate[0]);
            sortedDate.push(scoreAndDate[1]);
            sortedData.push(scoreAndDate[2]);
        })

        removingOldData(chartBox);
        generateNewGraph();
        console.log({data: sortedData}, resultsChart, sortedDate, sortedScore);   
        generateGraph({data: sortedData}, resultsChart, sortedDate, sortedScore);   

    } else if (checkedBox === "scoreRadio") {
        scores.forEach((score, i) => { sortedContent.push([score, date[i], SearchData.data[i]]) } );
        sortedContent.sort(function(a,b) {
            return a[0] - b[0];
        });

        sortedContent.forEach(scoreAndDate => {
            sortedScore.push(scoreAndDate[0]);
            sortedDate.push(scoreAndDate[1]);
            sortedData.push(scoreAndDate[2]);
        })

        removingOldData(chartBox);
        generateNewGraph();
        console.log({data: sortedData}, resultsChart, sortedDate, sortedScore);   
        generateGraph({data: sortedData}, resultsChart, sortedDate, sortedScore);   
    };

}

const generateNewGraph = () => {
    resultsChart = document.createElement('canvas');
    resultsChart.classList.add('.myChart');
    chartBox.appendChild(resultsChart);
} 

export default generateUi;